<?php
// $Id$

/**
 * @file
 * Defines date/time field types.
 */

/**
 *  Convert a date of any type or an array of date parts into a valid date
 *   object, after supplying any required but missing date parts.
 *
 *  Has special case for ISO dates which can be missing
 *  month and day and still be valid.
 *
 *  @param $date
 *    a date in any format, or a complete or partial array of date parts
 *  @param $timezone
 *    the name of the timezone this date is in
 *  @param $type
 *    could be DATE_ARRAY, DATE_UNIX, DATE_DATETIME, DATE_ISO, or DATE_OBJECT
 *  @param $default
 *    what to use as a default for any missing parts, 'now' for current time
 *    otherwise the smallest possible valid value will be inserted.
 */
function date_make_date($date, $timezone, $type = DATE_DATETIME, $default = 'now') {
  $timezone = date_make_timezone($timezone);
  if ($default == 'now') {
    $now = date_now($timezone);
  }
  $date = date_convert($date, $type, DATE_ARRAY);
  $date['year'] = !empty($date['year']) || $default != 'now' ? $date['year'] : date_format($now, 'Y');
  $date['month'] = !empty($date['month']) || $default != 'now' ? $date['month'] : date_format($now, 'm');
  $date['day'] = !empty($date['day']) || $default != 'now' ? $date['day'] : date_format($now, 'd');
  $date['hour'] = !empty($date['hour']) || $default != 'now' ? $date['hour'] : date_format($now, 'H');
  $date['minute'] = !empty($date['minute']) || $default != 'now' ? $date['minute'] : date_format($now, 'i');
  $date['second'] = !empty($date['second']) || $default != 'now' ? $date['second'] : date_format($now, 's');

  // ISO dates can have empty date parts
  // Others are expected to have at least a year, month, and day.
  if ($type != DATE_ISO) {
    $date['year'] = !empty($date['year']) ? $date['year'] : DATE_MIN_YEAR;
    $date['month'] = !empty($date['month']) ? $date['month'] : 1;
    $date['day'] = !empty($date['day']) ? $date['day'] : 1;
  }
  $date = date_convert($date, DATE_ARRAY, DATE_DATETIME);
  if (!empty($timezone)) {
    return date_create($date, $timezone);
  }
  return date_create($date);
}

/**
 * Implementation of hook_menu().
 */
function date_menu($may_cache) {
  if (!$may_cache) {
    if (module_exists('views')) {
      include_once(drupal_get_path('module', 'date') .'/date_views.inc');
    }
  }
}

/**
 * Implementation of hook_elements().
 *
 * This code and all the processes it uses are in date_elements.inc.
 */
function date_elements() {
  include_once(drupal_get_path('module', 'date') .'/date_elements.inc');
  return _date_elements();
}

/**
 * Implementation of hook_widget().
 */
function date_widget($op, &$node, $field, &$items) {
  switch ($op) {
    case 'default value':
      // Return a blank array, nothing done here but the empty array
      // will keep the content module from trying to create a default value.
      // The correct default values are inserted by the date element code.
      return array(0 => array('value' => NULL, 'value2' => NULL));

    case 'form':
      include_once(drupal_get_path('module', 'date_api') .'/date_api_elements.inc');
      include_once(drupal_get_path('module', 'date') .'/date_elements.inc');
      $db_info = content_database_info($field);
      $columns = array_keys($db_info['columns']);
      $element = array(
        $field['field_name'] => array(
          '#tree' => TRUE,
          '#weight' => $field['widget']['weight'],
          '#validate' => array('date_widget_validate' => array()),
          ));

      // Iterate through the available items, adding as many new ones as needed,
      // to build out the complete multi-valued field form element.
      $max = $field['multiple'] == 1 ? 2 + sizeof($items) : 0;
      foreach (range(0, $max) as $delta) {
        $element[$field['field_name']][$delta] = array(
          '#type' => 'date_combo',
          '#field' => $field,
          '#columns' => $columns,
          '#delta' => $delta,
          '#weight' => $delta,
          '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
        );
      }
      if (module_exists('date_repeat') && $field['multiple'] > 1) {
        $element[$field['field_name']]['repeat'] = array(
          '#type' => 'date_repeat',
          '#weight' => ($field['widget']['weight'] + .1),
          '#default_value' => $items['repeat'],
          );
      }
      return $element;
  }
}

/**
 * Implementation of hook_field().
 *
 */
function date_field($op, &$node, $field, &$items, $teaser, $page) {
  $field_name = $field['field_name'];
  if ($field['todate']) {
    $process = array('value', 'value2');
  }
  else {
    $process = array('value');
  }
  switch ($op) {
    case 'validate':
      // Don't try to validate if there were any errors before this point
      // since the element won't have been munged back into a date.
      if (!form_get_errors()) {
        foreach ($items as $delta => $item) {
          foreach ($process as $processed) {
            $error_field = $field['field_name'] .']['. $delta .']['. $processed;
            $error_field .= $field['widget']['type'] == 'date_select' ? '][year' : '';
            if ($processed == 'value' && $field['todate']
              && !date_is_valid($item['value'], $field['type'])
              && (date_is_valid($item['value2'], $field['type']))) {
              form_set_error($error_field, t("A 'From date' date is required for %field %delta", array('%delta' => $field['multiple'] ? intval($delta + 1) : '', '%field' => t($field['widget']['label']))));
            }
            if ($processed == 'value2'
              && $field['todate'] == 'required' && ($field['required']
              && date_is_valid($item['value'], $field['type'])
              && !date_is_valid($item['value2'], $field['type']))) {
              form_set_error($error_field, t("A 'To date' is required for %field %delta", array('%delta' => $field['multiple'] ? intval($delta + 1) : '', '%field' => t($field['widget']['label']))));
            }
          }
        }
      }
      break;

    case 'insert':
    case 'update':
      // Don't save empty values.
      foreach ($items as $delta => $item) {
        if (empty($item['value']) && $delta > 0) {
          unset($items[$delta]);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_field_formatter_info().
 */
function date_field_formatter_info() {
  return array(
    'default' => array('label' => t('Default'),
      'field types' => array('date', 'datestamp')),
    'long' => array('label' => t('Long'),
      'field types' => array('date', 'datestamp')),
    'medium' => array('label' => t('Medium'),
      'field types' => array('date', 'datestamp')),
    'short' => array('label' => t('Short'),
      'field types' => array('date', 'datestamp')),
    'iso' => array('label' => t('ISO'),
      'field types' => array('date', 'datestamp')),
    'timestamp' => array('label' => t('Timestamp'),
      'field types' => array('date', 'datestamp')),
    'feed' => array('label' => t('Feed'),
      'field types' => array('date', 'datestamp')),
    'ical' => array('label' => t('iCal'),
      'field types' => array('date', 'datestamp')),
    'format_interval' => array('label' => t('As Time Ago'),
      'field types' => array('date', 'datestamp')),
  );
}

/**
 * Implementation of hook_field_formatter().
 */
function date_field_formatter($field, $item, $formatter, $node) {
  // Get the complete date objects for the from and to dates in this field.
  $dates = date_field_object($field, $item);
  $dates['formatter'] = $formatter;
  $base = 'local';

  switch (strtolower($formatter)) {
    case 'format_interval':
      // Format interval has a different theme.
      return theme('date_format_interval', $field, $dates, $node);

    case('ical'):
      // for ical, send the db value with Z appended to indicate it is the gmt value
      $format = 'Ymd\THis';
      $append = 'Z';
      $base = 'db';
      break;

    case 'timestamp':
      $format = 'U';
      break;

    case('long'):
      $format = $field['output_format_custom_long'] > '' ? $field['output_format_custom_long'] : ($field['output_format_date_long'] ? $field['output_format_date_long'] : variable_get('date_format_long',  'l, F j, Y - H:i'));
      $format = date_format_granularity($format, date_granularity($field));
      break;

    case('medium'):
      $format = $field['output_format_custom_medium'] > '' ? $field['output_format_custom_medium'] : ($field['output_format_date_medium'] ? $field['output_format_date_medium'] : variable_get('date_format_medium',  'D, m/d/Y - H:i'));
      $format = date_format_granularity($format, date_granularity($field));
      break;

    case('short'):
      $format = $field['output_format_custom_short'] > '' ? $field['output_format_custom_short'] : ($field['output_format_date_short'] ? $field['output_format_date_short'] : variable_get('date_format_short', 'm/d/Y - H:i'));
      $format = date_format_granularity($format, date_granularity($field));
      break;

    case('iso'):
      $format = DATE_FORMAT_ISO .'P';
      break;

    case('feed'):
      $format = 'D, j M Y H:i:s O';
      break;

    default:
      $format = $field['output_format_custom'] > '' ? $field['output_format_custom'] : ($field['output_format_date'] ? $field['output_format_date'] : variable_get('date_format_short', 'm/d/Y - H:i'));
      $format = date_limit_format($format, date_granularity($field));
      break;
  }
 // Iterate through the From and To dates to format them, using the format selected above.
  if ($field['todate']) {
    $process = array('value', 'value2');
  }
  else {
    $process = array('value');
  }
  foreach ($process as $processed) {
    $date = $dates[$processed][$base]['object'];
    if (is_object($date)) {
      $dates[$processed]['formatted'] = date_format($date, $format) . $append;
    }
    else {
      $dates[$processed]['formatted'] = '';
    }
  }

  return theme('date_formatter', $dates, $field, $formatter, $node);
}

/**
 * Use the Date API to get an object representation of a date field
 *
 * @param array $field
 * @param array $item - a node field item, like $node->myfield[0]
 *
 * @return array that holds the From and To date objects
 *  Each date object looks like:
 *       date [value] => array (
 *         [db] => array (  // the value stored in the database
 *           [object] => the datetime object
 *           [datetime] => 2007-02-15 20:00:00
 *         )
 *         [local] => array (  // the local representation of that value
 *           [object] => the datetime object
 *           [datetime] => 2007-02-15 14:00:00
 *           [timezone] => US/Central
 *           [offset] => -21600
 *         )
 *      )
 */
function date_field_object($field, $item) {
  if (!is_array($field) || !is_array($item)) return $dates;
  if ($field['todate']) {
    $process = array('value', 'value2');
  }
  else {
    $process = array('value');
  }
  foreach ($process as $processed) {
    if (empty($item[$processed])) {
      $dates[$processed] = NULL;
    }
    else {
      // create a date object with a gmt timezone from the database value
      $value = $field['type'] == 'DATE_UNIX' ? "@$value" : $value;
      $date = date_create($value, timezone_open('UTC'));
      $dates[$processed] = array();
      $dates[$processed]['db']['object'] = $date;
      $dates[$processed]['db']['datetime'] = date_format($date, DATE_FORMAT_DATETIME);

      // For no timezone handling, set local value to the same as the db value.
      if ($field['tz_handling'] == 'none'
        || !in_array('hour', date_granularity($field))
        || $field['tz_handling'] == 'date' && empty($item['timezone'])) {
          $obj->local = $obj->db;
      }
      else {
        $timezone = date_get_timezone($field['tz_handling'], $item['timezone']);
        date_timezone_set($date, timezone_open($timezone));
        $dates[$processed]['local']['object'] = $date;
        $dates[$processed]['local']['datetime'] = date_format($date, DATE_FORMAT_DATETIME);
        $dates[$processed]['local']['timezone'] = $timezone;
        $dates[$processed]['local']['offset'] = date_offset_get($date);
      }
    }
  }
  return $dates;
}

/**
 * $field['granularity'] will contain an array like ('hour' => 'hour', 'month' => 0)
 * where the values turned on return their own names and the values turned off return a zero
 * need to reconfigure this into a simple array of the turned on values
 */
function date_granularity($field) {
  if (!is_array($field) || !is_array($field['granularity'])) {
    $field['granularity'] = drupal_map_assoc(array('year', 'month', 'day'));
  }
  return array_values(array_filter($field['granularity']));
}

/**
 *  Function to figure out which timezone applies to a date and select it
 */
function date_get_timezone($handling, $timezone = '') {
  switch ($handling) {
    case('site'):
      $timezone = date_default_timezone_name(FALSE);
      break;
    case('date'):
      $timezone = empty($timezone) ? $timezone : date_default_timezone_name();
      break;
    case('user'):
      $timezone = date_default_timezone_name();
    case('none'):
      $timezone = 'UTC';
      break;
    default:
      $timezone = 'UTC';
  }
  return $timezone > '' ? $timezone : 'UTC';
}

/**
 * Implementation of hook_help().
 */
function date_help($section) {
  switch ($section) {
    case 'admin/help#date':
      return t('<p>Complete documentation for the Date and Date API modules is available at !link.</p>', array('!link' => l('http://drupal.org/node/92460', 'http://drupal.org/node/92460')));
      break;
  }
}

function date_views_query_alter(&$query, &$view) {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_query_alter(&$query, &$view);
}

/**
 * Implementation of hook_form_alter().
 * Make sure date information gets updated.
 */
function date_form_alter($form_id, &$form) {
  if ($form_id == 'views_edit_view') {
    $form['#submit'] = array_merge($form['#submit'], array('date_clear_all' => array()));
  }
}

/**
 * Empty or reset cached values.
 *
 * @param $remove
 *   whether or not to completely remove the caches.
 */
function date_clear_all($remove = FALSE) {
  if ($remove) {
    cache_clear_all('date_browser_views', 'cache_views');
  }
  else {
    if (module_exists('views')) {
      date_views_browser_get_views(TRUE);
    }
  }
}

/**
 * Wrapper functions for date administration.
 */
function date_widget_info() {
  include_once(drupal_get_path('module', 'date') .'/date_admin.inc');
  return _date_widget_info();
}

function date_widget_settings($op, $widget) {
  include_once(drupal_get_path('module', 'date') .'/date_admin.inc');
  return _date_widget_settings($op, $widget);
}

function date_field_info() {
  include_once(drupal_get_path('module', 'date') .'/date_admin.inc');
  return _date_field_info();
}

function date_field_settings($op, $field) {
  include_once(drupal_get_path('module', 'date') .'/date_admin.inc');
  return _date_field_settings($op, $field);
}

/**
 * Wrapper functions for views hooks.
 */
function date_views_filters($field) {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_filters($field);
}
function date_views_timestamp_filter_handler($op, $filter, $filterinfo, &$query) {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_timestamp_filter_handler($op, $filter, $filterinfo, &$query);
}
function date_views_filter_handler($op, $filter, $filterinfo, &$query, $field_type = 'iso') {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_filter_handler($op, $filter, $filterinfo, &$query, $field_type);
}
function date_views_handler_filter_date_value_form($field) {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_handler_filter_date_value_form($field);
}
function date_views_timestamp_argument_range_handler($op, &$query, $argtype, $arg = '') {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_timestamp_argument_range_handler($op, &$query, $argtype, $arg);
}
function date_views_argument_range_handler($op, &$query, $argtype, $arg = '', $field_type = 'iso') {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_argument_range_handler($op, &$query, $argtype, $arg, $field_type);
}
function date_views_style_plugins() {
  include_once('./'. drupal_get_path('module', 'date') .'/date_views.inc');
  return _date_views_style_plugins();
}

/**
 * Callback for pathauto.
 */
function date_pathauto_node($op, $node = NULL) {
  include_once(drupal_get_path('module', 'date') .'/date_pathauto.inc');
  return _date_pathauto_node($op, $node);
}

/**
 *  Theme date formatter.
 *
 *  @param $dates = an array of the field From and To date objects, as created by date_field_object().
 *  @param $field = the field settings
 *  @param $node = node information, this is not always available and not
 *     always the full node, it depends on what value was provided to the formatter.
 *     Only the nid is always guaranteed to be available.
 *
 *  Useful values:
 *    $field['type_name'] - the content type
 *    $field['type'] - the field type
 *    $node->nid - the node nid, get other node values using node_load($node->nid)
 *    $dates['value']['object']->local->timestamp - the local timestamp for the From date
 *    $dates['value2']['object']->local->timestamp - the local timestamp for the To date
 *    $dates['value']['object']->db->timestamp - the timestamp of the From date database (GMT) value
 *    $dates['value2']['object']->db->timestamp - the timestamp of the To date database (GMT) value
 *    $dates['value']['local']['formatted'] = formatted From date, i.e. 'February 15, 2007 2:00 pm';
 *    $dates['value2']['local']['formatted'] = formatted To date, i.e. 'February 15, 2007 6:00 pm';
 */
function theme_date_formatter($dates, $field, $formatter, $node) {
  // Pass the date object with the formatted dates to the date_display_combination() theme.
  return theme('date_display_combination', $field, $dates, $node);
}

/**
 *  Theme from/to date combination in the view.
 *
 *  @param $field = the field settings
 *  @param $node = node information, this is not always available and not
 *     always the full node, it depends on what value was provided to the formatter.
 *     Only the nid is always guaranteed to be available.
 *  @param $dates - an array of date information, see explanation for date_field_object() for details.
 *
 *  Useful values:
 *    $field['type_name'] is the content type
 *    $field['type'] is the field type
 *    $node->nid is the node nid, get other node values using node_load($node->nid)
 *    $dates['value']['local']['object'] - the local date object for the From date
 *    $dates['value2']['local']['object'] - the local date object for the To date
 *    $dates['value']['local']['datetime'] - the datetime value of the From date database (GMT) value
 *    $dates['value2']['local']['datetime'] - the datetime value of the To date database (GMT) alue
 *    $dates['formatter'] = formatter name, i.e. 'default';
 *    $dates['value']['local']['formatted'] = formatted From date, i.e. 'February 15, 2007 2:00 pm';
 *    $dates['value2']['local']['formatted'] = formatted To date, i.e. 'February 15, 2007 6:00 pm';
 */
function theme_date_display_combination($field, $dates, $node = NULL) {
  $date1 = $dates['value']['formatted'];
  $date2 = $dates['value2']['formatted'];
  if (empty($date1) && empty($date2)) {
    return '';
  }
  elseif ($date1 == $date2 || empty($date2)) {
    return '<span class="date-display-single">'. $date1 .'</span>';
  }
  else {
    // Don't repeat values in the 'to' date that are in the 'from' date.
    // Will change February 1, 2007 10:00 AM - February 1, 2007 11:00 AM
    // into February 1, 2007 10:00 AM - 11:00 AM.
    $date2 = str_replace($date1, '', $date2);
    return '<span class="date-display-start">'. $date1 .'</span><span class="date-display-separator"> - </span><span class="date-display-end">'. $date2 .'</span>';
  }
}

/**
 * Theme a format interval for a date element
 *
 *  @param $field = the field settings
 *  @param $node = node information, this is not always available and not
 *     always the full node, it depends on what value was provided to the formatter.
 *     Only the nid is always guaranteed to be available.
 *  @param $dates - an array of date information, see explanation for date_field_object for details.
 *  @return a formatted display
 *
 */
function theme_date_format_interval($field, $dates, $node = NULL) {
  // Time to compare dates to
  $now = date_format(date_create('now', timezone_open(date_default_timezone_name())), 'U');

  // Pull local timestamps out of date objects.
  $start = date_format($dates['value']['local']['object'], 'U');
  if (!$end = date_format($dates['value2']['local']['object'], 'U')) {
    $end = $start;
  }
  // 1) The date is entirely in the future
  if ($now < $start) {
    return t('!time', array('!time' => format_interval($start - $now)));
  }
  // 2) Ongoing date
  elseif ($now > $start && $now <= $end) {
    //return t('Started !time ago', array('!time' => format_interval($now - $timestamp1)));
    return t('ongoing');
  }
  // 3) Date is in the past
  else {
    return t('!time ago', array('!time' => format_interval($now - $end)));
  }
}

/** @} End of addtogroup themeable */